\chapter{Scala programming language}

\section{Important language features}

%TODO: scala implicit casts

%TODO: scala function types (and nececity to duplicate code)

%TODO: extending function type, overriding apply()

\subsection{Methods and functions in Scala}
\label{subsec:metandfun}

There is an important difference between methods and functions in Scala. Methods have the same concept as in Java or other object oriented languages - they are an integral, compile-time part of their class and the only context that they can refer to is their class instance, arguments or static members. They can't be passed around, so no additional context is needed. Every invocation has to be performed on a class instance, allowing the compiler to correctly assign the \textit{this} reference. Simple example of a method can be the following:

\lstset{style=Scala}
\begin{lstlisting}
class Class {
def method(arg: String): String = s"Called method($arg) on $this"
}
val obj = new Class()
println(obj.method("Hello"))
\end{lstlisting}

On the other hand, functions are first-class values that have a type and can be passed into other functions or methods, or be part of expressions. Internally, they are represented as closure objects, carrying around their context and the compiled code stored as a method in the closure type. Functions are created using lambda expressions:

\lstset{style=Scala}
\begin{lstlisting}
val function: (String) => Unit = arg => println(obj.method(arg))
function("Hello again!")
List("One", "Two", "Three").foreach(function)
\end{lstlisting}

The \lstinline|obj| reference is \textit{captured} inside the closure, the function is not tied to any class. 



\subsection{Eta-expansion}
\label{subsec:etaexpansion}

Because the strengths of Scala lie in its functional features, it is often handy to be able to convert methods to functions. This is called \textit{eta-expansion} and is quite straightforward (assuming we are inside the class):

\lstset{style=Scala}
\begin{lstlisting}
val methodFunction: (String) => String = arg => method(arg)
\end{lstlisting}

Scala has a special operator that makes it even simpler:

\lstset{style=Scala}
\begin{lstlisting}
val methodFunction = method _
\end{lstlisting}

And in some expression contexts, this conversion is implicit:

\lstset{style=Scala}
\begin{lstlisting}
List("One", "Two", "Three").map(method)
\end{lstlisting}

In this example, the conversion is implicitly applied to an argument of a method in order to meet the parameter type. The expansion in this case will be always implicit, unless one of the following conditions is met:
\begin{enumerate}
	\item The method has overloads.
	\item There is an implicit typecast required from the expanded type to the parameter type.
\end{enumerate}

%TODO: Generic methods vs. functions

%TODO: methods vs. functions in scala, eta expanstion

%TODO: multiple combination

%TODO: covariance and contravariance

\subsection{Function types}
\label{subsec:functiontypes}

The first-class value functions have to be anchored somewhere in the Scala type system in order for the type inference, type checking and other mechanisms to work correctly. The type of a function is unambiguously determined by its signature, i.e. the number and types of arguments and the type of the return type. Consequentially, the function types have to be generic and able to accept different numbers of type arguments.

Scala as a language doesn't support variadic generic types (as opposed to languages like C++), so there has to be a different type with different number of type arguments for every possible number of arguments of a function. Currently, there are traits for functions accepting 0 to 22 arguments:

\lstset{style=Scala}
\begin{lstlisting}
trait Function0[+R]
...
trait Function22[-T1, ..., -T22, +R]
\end{lstlisting}

These traits have syntactic aliases in the language:

\lstset{style=Scala}
\begin{lstlisting}
() => R
...
(T1, ..., T22) => R
\end{lstlisting}

Functions with more than 22 arguments can't exist in Scala and have to be replaced by function accepting tupled arguments.

The necessity to represent functions with various argument numbers as various traits leads to code duplication.

\section{DSLs in Scala}

\subsection{Infix operators}
\label{subsec:infixops}

One of the features that support both the functional flavor of Scala and the DSL building capabilities is the possibility to call methods like infix operators. Any method that has exactly one argument can be called using this special syntax:

\lstset{style=Scala}
\begin{lstlisting}
class RichInt {
  def plus(other: RichInt) = ???
}
...
val res = x plus y
\end{lstlisting}

The syntax is even more powerful if we take into consideration that Scala allow the methods to have non-alphanumeric names:

\lstset{style=Scala}
\begin{lstlisting}
def +(other: RichInt) = ???
...
val res = x + y
\end{lstlisting}

This approach allows us to use the infix syntax with existing methods and with methods that weren't designed with the intention to be used that way. It has, however, a downside as well - it doesn't allow us to create an infix operator that would accept as its first argument a type without actually changing the type and adding the method to its definition. Scala doesn't directly support declaring extension methods on types (unlike C\#, Kotlin and other languages) and so the only way to solve this problem is to introduce implicit typecast to a custom type and to add the infix operator as a method to it.

% TODO: Compare to infix operators in Kotlin

\section{Def Macros}
\label{sec:defmacros}

Def Macros are quite a unique feature among all the widely used programming languages. It allows a library writer to write a code that will be executed upon compilation of the unit which references the library. This basically means that simple compiler extensions in Scala can behave like libraries, can be distributed and used just like one.

The API is very simple - there are methods marked as \textit{macros} in the library code. Whenever a call of this method is being compiled, the compiler invokes the macro implementation, which is a normal Scala method. It will receive an AST\footnote{Abstract Syntax Tree - the product of the syntax analysis of a source code} of the arguments passed to the original method and produce an AST, which will replace it in the code.

The feature was introduced in Scala 2.10 as an experimental feature, and it became very popular and successful. The current goal is to have a fully supported feature in Scala 2.12.

%TODO: Example

The only limitation is that the macro can't be used in the same compilation unit where its declaration and implementation is, as the Scala compiler has to have access to the already compiled implementation when compiling the usages.

\subsection{Building syntax trees}
\label{subsec:buildingast}

The macro usually has to be able to perform 2 steps:

\begin{enumerate}
	\item Parse the AST of the arguments
	\item Build a new syntax tree to replace it
\end{enumerate}

The syntax trees are represented by tree node classes with \inlinecode{apply()} and \inlinecode{unapply()} methods accepting / returning their descendants. The trees can be examined using pattern matching.

Unfortunately, there is not a lot of documentation available for the syntax tree structure. The official Scala documentation has only a few examples and the types in the code lack the documentation as well (in Scala 2.11). 

%TODO: Reference https://github.com/wolfe-pack/wolfe/wiki/Scala-AST-reference

One of the possible options to find out how certain expressions are parsed into ASTs is to create a simple macro that will accept any expression, print its AST and replace itself by the same expression again:

\lstset{style=Scala}
\begin{lstlisting}
def printAst(arg: Any): Any = macro printAst_impl

def printAst_impl(c: Context)(arg: c.Expr[Any]): c.Expr[Any] = {
  import c.universe._
  println(showRaw(arg.tree))
  arg
}
\end{lstlisting}

The output that is written to \textit{stdout} by a macro implementation is displayed as a warning in the compilation process, so there is no need to run the program to see the results of \inlinecode{printAst()}, it is sufficient just to compile it.

For example, \inlinecode{printAst(x + 1)} produces the following compile-time warning:

\lstset{style=Dump}
\begin{lstlisting}
Warning:scalac: Block(List(), Function(List(ValDef(Modifiers(PARAM | SYNTHETIC), TermName("i"), TypeTree(), EmptyTree)), Apply(Select(This(TypeName("MacroTest")), TermName("increment")), List(Ident(TermName("i"))))))
\end{lstlisting}


