\chapter{Motivation and use cases}

Almost every basic course of programming and algorithmisation uses the same example when talking about the complexity of algorithms and about methods of constructing them - sorting. Being a very common real-life problem with a variety of solutions using different principles with corresponding complexities, it is a nice practical introduction into this problematics. The outcome for the student is the following - it is always important to select the adequate algorithm for solving the problem.

So now, let's expand the example a little bit. Supposing we have the basic arsenal of sorting algorithms including:

\begin{itemize}
	\item Selection sort
	\item Insertion sort
	\item Bubble sort
	\item Quick sort
	\item Merge sort
	\item Heap sort
	\item Radix sort
\end{itemize}

We know for sure that the first three algorithms have worse time complexity than the rest. In real conditions, this doesn't mean that they have to be necessarily slower on every input of every size. The faster algorithms often tend to have complex initialization and data preprocessing, which gives an advantage to asymptotically slower algorithms on inputs that are small enough that their processing time is comparable to the initialization. 

In general, it is more useful to optimize for larger inputs, because the difference between algorithms with better asymptotic complexity\footnote{The so-called Big O notation} and the worse ones grows with the size of the input, so the impact of the complexity is much higher on larger inputs. In cases where the input size isn't limited, the algorithm with best possible asymptotic complexity should be preferred.

The described approach might lead to inefficient computations over small inputs, which 

Whenever using an algorithm, we need to think about the use case, the possible input data, and make a choice. If the requirements for the program change in the future, this choice could have a negative impact and have to be changed.

\lstset{style=Scala}
\begin{lstlisting}
val result = algorithm1(input)
\end{lstlisting}

\lstset{style=Scala}
\begin{lstlisting}
val result = algorithm2(input)
\end{lstlisting}

This process could be simply avoided by using all of the algorithm implementations and letting the program decide which one to choose at runtime.

\lstset{style=Scala}
\begin{lstlisting}
val result = (algorithm1 or algorithm2)(input)
\end{lstlisting}

Doing so has a few valuable advantages:
\begin{itemize}
	\item It knows what the input is at the decision time
	\item It might react to the state of the system
	\item It knows what the performance of the algorithm was in the previous runs
\end{itemize}

In other words, the program can adapt its runtime to various conditions in order to improve its performance.

The entire adaptation will be performed based on collected runtime data - no analysis of the functions will be required.

\section{Use cases}

We can introduce a couple of basic scenarios where the adaptivity might help with the overall performance.

\subsection{Input adaptation}

Imagine we have two different algorithms with different complexities, one with better asymptotic complexity (the big-O notation), the other, however, with lower multiplicative constant. It might be better to use the algorithm with worse asymptotic complexity for smaller inputs, and the other one for larger inputs. Adaptive program can discover this by itself and use the most appropriate algorithms according to the inputs, without the programmer having to describe the complexities, compute them, measure anything.

\subsection{Environment adaptation}

This scenario is based on the idea of performing longer tasks that depend on the environment - the network, database, external servers, etc. If we have more options how to perform an action in an environment like this (e.g. example, sending a request to a different web service, using a different database system, etc.), we can let the system adaptively decide which one to use in current conditions. The system can then reflect variable response times.

\subsection{Library selection}

If we have a variety of libraries to perform the same task to chose from, we can let the system adaptively decide each time. Example could be the libraries for parsing, image processing, mathematical computations and basically any library that we use to repeatedly perform more complex tasks. We don't have to find out which one runs faster for which inputs, the system will do it for us. In addition, if a library improves its performance after updating to a newer version, it will be reflected as well.

\subsection{Implementing experimental alternatives}

If we have a time-critical method in our system and we want to rewrite it in order to improve the performance, we can introduce it to the system and let the system adaptively try to use it and observer the results, improving it iteratively. When the alternative reaches better overall performance, we can remove the original method.

\section{Goals of the thesis}

%TODO: Mention -transparent usage of the adapted function -fluent API -basic selection strategies -limit the overhead to make it usable for faster functions as well