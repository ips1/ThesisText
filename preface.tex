\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

In modern software engineering, performance awareness has become a first class concern. The systems deal with growing amounts of data, with higher emphasis on the real-time processing and with more limited environments for embedded solutions, while we are reaching hardware limitations. It is the responsibility of the developer to assure that his code will not only work correctly, but will also be optimized and fast enough to meet these expectations.

The actual performance-aware programming can often be difficult and problematic for the developer, who is forced to make an assumptions about the speed of his program. The performance in general is, however, a dynamic and not a static feature. Even though it is possible to analyze the algorithm complexity at design-time, the result will always be only an approximation, as it works with abstract elementary computational steps. In reality, the programs often behave in a different way due to the influence of CPU\footnote{Central Processing Unit} cache, memory locality, I/O\footnote{Input / Output operation} operations, parallelism and many other factors. 

The only way how to actually find out if given implementation is fast enough - possibly faster than some other variant - is through a thorough testing process covering all the possible inputs and executed in the actual production environment. This process is complicated, costly, and should be repeated after every change in the code, as it can have a previously unexpected impact. It can be partially automatized by introducing performance constraints to the classic unit tests. There is an active research in this area, e.g. \cite{bulej_capturing_2012,horky_performance_2013,horky_utilizing_2015}.

Considering a common case where a programmer needs to decide which implementation option of some functionality to use, the discussed solution has some major downsides. First, he needs to design the tests, select test data, execute them and make decisions based on the results, which is a non-negligible effort, especially in a common software engineering process. Second, the decision that is made is final - once executed, the program will always have to use only that selected implementation. There are many cases where the performance of the implementations varies for different inputs or in different environments, and we would like our application to always use the best possible implementation, in other words, to adapt its execution to these conditions.

To address these problems and to simplify the performance-aware development in general, we propose a completely new approach in development, where the programmer identifies the implementation options of a function in the code using a programming language construct. At execution, the system tracks the performance of the implementations involved and makes a new decision for each run of the function based on the inputs and current trends in the run times.

The goal of this thesis is to design a framework that would allow this way of development and to implement its prototype. It will be tested in various scenarios common for many applications where the approach might be beneficial, and the actual advantages and problems of proposed solution will be evaluated. The target platform of both the design and the implementation is the Scala programming language (\cite{noauthor_scala_nodate}), because it has a very flexible syntax suitable for creating language-like constructs while being statically typed with both object-oriented and functional foundations. In addition, it compiles to the Java bytecode and runs on the JVM\footnote{Java Virtual Machine}, which makes it portable and open to the variety of \mbox{Java-based} libraries. 

Many frameworks for data processing and similar tasks where the adaptation could be employed are either implemented or have interfaces in Scala, mainly for its high expressive powers. An example can be the Spark framework \cite{noauthor_apache_nodate}, which will be used in the evaluation process.

\subsubsection{Structure of the text}

In the first chapter of this work, the Scala language features that are not common among current object-oriented programming languages are introduced. Most of them will be mentioned and used in further chapters, so it serves as a brief introduction for a reader who knows basic object-oriented and functional languages, but does not have a deep knowledge of advanced Scala features.

The second chapter serves as a brief overview of the framework developed as a part of this thesis. More detailed goals are stated and a basic structure of the solution is outlined.

The third chapter is dedicated to the framework API. It begins with the requirement analysis and most simple use cases, followed up by possible drafts and their problems. Then, the actual design is presented, along with its evaluation and more advanced scenarios and extensions. The whole chapter is written independently on the framework implementation, and is based only on the requirements and a basic notion of the functionality.

The fourth chapter is more theoretically focused. It introduces the functionality of the selection part of the framework on an abstract level. The whole process of deciding between multiple functions based on the historical observations of their runs is explained. Several algorithms are presented, tested and compared. In addition, more concrete improvements are suggested to increase the selection precision and to speed up the invocation process.

In the fifth chapter, the whole framework implementation is briefly presented. Concepts from the third and fourth chapters are incorporated into an actual Scala program. A couple of problems is mentioned and solved. Last but not least, the options that the framework user has of customizing and possibly extending the functionality are discussed.

The goal of the sixth chapter is to try out the framework in real-life scenarios and to evaluate the benefits that it brings. For that, a couple of different problems will be used, including basic selection between algorithms, JSON parsing or adapting to quickly changing network environment. A part of the chapter is devoted to the Spark framework for distributed data processing, which offers a great potential for adaptive execution.

In the last, seventh chapter, other work that is related to the problem of performance adaptation, measurement, prediction and similar topics is analyzed.