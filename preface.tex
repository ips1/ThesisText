\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

In modern software engineering, performance awareness has become a first class concern, as the systems deal with growing amounts of data, with higher emphasis on the real-time processing, implement embedded solutions as a part of the IoT and in general, as the requirements demand faster software, but we are reaching the hardware limitations. It is the concern of the developer to assure that his code will not only work correctly, but will optimized and fast enough to meet these demands.

Performance in general is a dynamic, not a static feature. Even though it is possible to analyze the algorithm complexity at the design-time, the result will always be only an approximation, asymptotic in general, as it works with abstract elementary computational steps. In reality, the programs often behave in a different way due to problems with CPU cache and memory locality, I/O operations, parallelism and many other factors. The only way how to actually find out which implementation has better performance is through a thorough testing process covering all the possible inputs and executed in the actual production environment. This process is complicated, costly, and should be repeated after any change in the program code, as it can have an unexpected impact. It can be partially automatized by introducing performance constraints to classic unit tests, and there is an active research in this area, e.g. \cite{bulej_capturing_2012,horky_performance_2013,horky_utilizing_2015}.

The solution based on unit tests has some major downsides. First, it requires the developer to design the tests, select the test data and make the decisions based on the results, which is a non-negligible effort, especially in a common software engineering process. Second, the decision made is final - once executed, the program will always have to use only the one, selected implementation. There are many cases where the performance of the implementations varies for different inputs or in different environments, and we would like our application to adapt to these conditions and to always use the best possible implementation.

To address these problems and to simplify the performance-aware development in general, we propose a completely new approach, in which the programmer simply identifies the implementation variants of a function in the code using a programming language construct. Then, he uses the function throughout the code without any concerns, while the system tracks the performance of the implementations involved and makes a new decision for each run of the function based on the inputs and current trends in the run times.

The goal of this thesis is to design a framework that would allow this way of development, to implement a prototype, to test it in various scenarios common for many applications, and to evaluate the benefits and problems of the proposed approach. The target platform of both the design and the implementation is the Scala programming language (\cite{noauthor_scala_nodate}), as it has a very flexible syntax suitable for creating language-like constructs, while being a statically typed language with both object oriented and functional foundations. In addition, many frameworks for data processing and similar tasks are either implemented or have interfaces in Scala, mainly for its high expressive powers. An example can be the Spark framework \cite{noauthor_apache_nodate}, which will be used in the evaluation process.

\subsubsection{Structure of the text}

In the first chapter of this work, the Scala language features that are not common among the current object-oriented programming languages are introduced. Most of them will be mentioned and used in further chapters, so it serves as a brief introduction for a reader that knows basic OOP and functional languages, but does not have a deep knowledge of advanced Scala features.

The second chapter serves as a brief overview of the framework developed as a part of this thesis. More detailed goals are presented and a basic structure of the solution is outlined.

The third chapter is dedicated to the framework API. The reader is guided through the entire process of designing the API, from the requirement analysis and most simple use-cases, through possible drafts and their problems, the options that Scala offers, the actual design, its usage and problems, ending with more advanced scenarios and extensions. The whole chapter is written independently on the framework implementation, is based only on the requirements and a basic notion of the functionality.

The fourth chapter is more theoretically focused. It explains the functionality of the selection part of the framework on an abstract level. The whole process of deciding between multiple functions is explained, and algorithms used within are presented, tested and compared. In addition, more concrete improvements are suggested to improve the selection and to speed up the invocation process.

In the fifth chapter, the whole framework implementation is briefly presented. Concepts from the third and fourth chapters are incorporated into an actual Scala program. A couple of problems are mentioned and solved. Last but not least, the options that the framework user has of customizing and possibly extending the functionality are discussed.

The goal of the seventh chapter is to try out the framework in real-life scenarios and to evaluate benefits that it brings. For that, a couple of different usage scenarios will be used, including basic selection between algorithms, JSON parsing or adapting to quickly changing network environment. A part of the chapter is devoted to the Spark framework for distributed data processing, which offers a great potential for adaptive execution.

In the last, eighth chapter, other work that is related to the problem of performance adaptation, measurement, prediction and similar topics is analyzed.