\chapter{API and the basic design}
\label{chapter:api}

API (Application Programming Interface) is a key component of every framework or library. It defines how a stand-alone piece of code (a function, class, module, or even entire running application) interacts with its environment. This includes the possible calls / requests, format of the data that is passed in as arguments and the data that is received as a result of the action. In our case, the API will be used to access functionality of our library from the user's own code.

One of the key tasks of this thesis is to research the potential possibilities of API for the adaptation framework, to design it to be as fluent and expressive as possible using the Scala programming language features described in chapter \ref{chap:scala} and to analyze the problems and limitations that it has. 
Some key design decisions about the functionality of the entire framework that are tightly connected to the API design have to be discussed as well.

\section{Design of the API}

\subsection{Basic API requirements}

The library itself should not require much interaction from the programmer. The usage would be based on performing some initial configuration, marking method implementations that are interchangeable, and then calling repeatedly either one of the methods marked, or some special method, and receiving correct results from one of the implementations. The typical use-case of our API could be described in the following way:

\textit{User has a class with two methods, \inlinecode{method1()} and \inlinecode{method2()}, and uses the framework simple API to create a third method in the same class, \inlinecode{method()}, that adaptively uses one of the other two methods. If he wants to change the behavior of the adaptation (method selection) process, he can do it directly in the definition of the \inlinecode{method()}.}

The important point is that we want the result of combining the methods to behave exactly like a normal function or method. The caller shouldn't know and shouldn't have to know that he is calling an object that is somehow special. This allows us to limit the adaptation framework interaction in our system to one place which could be hidden inside a separate module behind an interface, and gives us the possibility to quickly replace it or remove it completely.

We can make a list of the \textbf{basic requirements}:
\begin{enumerate}
	\item Create a method by combining two or more different methods (stating that they can be called interchangeably)
	\item Define some basic adaptation behavior for the function
	\item Make some more complex configuration changes for the whole library
\end{enumerate}

\subsection{Possible API drafts}

The core part of the whole API and the mechanism that will define the usability of the framework is the method combination definition. JVM classes in general have the limitation that once they are loaded by a \textit{classloader}, they cannot be modified, and neither do their methods. Generating new methods at runtime is therefore extremely difficult. An alternative to that would be to create functions instead, which behave like normal Java objects\footnote{the difference between methods and functions in explained in section \ref{sec:metandfun}}. From the point of view of the potential caller, a function can be used almost identically as a method. 

This leaves us with two basic approaches to the API.

\subsubsection{API based on methods}

This variant would have to be at least partially based on compile-time actions and would have to work with annotations (in case that we do not want to create custom language extensions).

The combination definition could work roughly in the following way:
\lstset{style=Scala}
\begin{lstlisting}
@ClassWithCombinations
class Functions {
  @CombineInto("combinedMethod")
  def method1(arg: Int) = ???
  
  @CombineInto("combinedMethod")
  def method2(arg: Int) = ???
}
\end{lstlisting}

There are multiple ways of implementing such an API, we are going to discuss the following two:

\begin{enumerate}
	\item Using Scala compile-time macros
	\item Using aspect weaving
\end{enumerate}

Scala macros would be able to modify the AST of the \inlinecode{Functions} class to contain three methods (\inlinecode{method1}, \inlinecode{method2} and \inlinecode{combinedMethod}) with the same signature. The typecheck would be done during compile time in the macro execution. Notice a few problems and limitation that this solution has:

\begin{itemize}
	\item The \inlinecode{@ClassWithCombinations} annotation would be necessary for each class that would contain the combined function, because the AST modification of the class can be done only when processing an annotation of the entire class
	\item Consequentially, it would be possible to combine only methods within one class
	\item The IDEs do not process the macros upon code inspections and code highlighting, and would mark the combined methods as non existing, which would be extremely inconvenient (this could potentially be fixed by adding a dummy implementation of the combined method, which would impose more work on the user)
	\item The string-based name of the combined method is error prone - methods could be excluded from the combination due to typos in the name, or an existing method could be overwritten by mistake
\end{itemize}

The second option of using an aspect weaver would lead to a very similar API with different limitations. The weaver does not allow us to modify the class and to generate a method, but can intercept calls of annotated methods using an annotation pointcut. We could either intercept all calls on the methods combined into the same group and use the selection mechanism every time (which would not allow the user to invoke any of the combined methods without the selection process), or have a dummy method with empty implementation, just like in the previous case, and intercept its calls. Looking for other methods with annotation from the pointcut would require us to use reflection.

\subsubsection{API based on functions}

This option would work with functions as first-class values (and the runtime objects representing them). It might look the following way:

\lstset{style=Scala}
\begin{lstlisting}
val function1 = ???
val function2 = ???
val combinedFunction = /* Expression to combine function1 and function2 */
val result = combinedFunction(data)
\end{lstlisting}

The \inlinecode{combinedFunction} would be an object that would confirm to the \inlinecode{Function1} trait (see \ref{subsec:functiontypes}) and thus could be used as a normal function.

The main inconvenience of the design is that it works only with functions. Existing methods can be treated as functions using \textit{eta-expansion}(see section \ref{subsec:etaexpansion}), so methods can be combined as well almost with no effort. The other way around, creating a new method, is a little bit more complicated. Both will be discussed later.

Apart from these complications, this approach a lot of advantages. It can be used at runtime in any method to create a temporary function, the type checking and IDE tools work on it, it can be fluent and flexible. The combinations can be created anywhere in the code. And, in general, this approach fits the functional concept of Scala.

The function combination expression technically has to be a higher-order function (or method) . We would like it to conform to the functional Scala design patterns. As an inspiration, lets have a look at a different case where we generate one function from two different ones - function composition. This can be done in Scala using a \inlinecode{andThen} method defined on the function type traits (see \ref{subsec:functiontypes}):

\lstset{style=Scala}
\begin{lstlisting}
val timesTwo = (x: Int) => { x * 2 }
val plusOne = (x: Int) => { x + 1 }
val timesTwoPlusOne = timesTwo.andThen(plusOne)
\end{lstlisting}

We can achieve even more readable and natural looking code if we take advantage of the infix operator syntax (see \ref{subsec:infixops}):

\lstset{style=Scala}
\begin{lstlisting}
val timesTwoPlusOne = timesTwo andThen plusOne
\end{lstlisting}

Chaining of the methods / operators is possible as well:

\lstset{style=Scala}
\begin{lstlisting}
val manyOperations = timesTwo andThen plusOne andThen plusOne andThen timesTwo
\end{lstlisting}

Inspired by this readable and very simple syntax to compose functions which relies on only the basic syntactic features of Scala, we can try to design the combination expression exactly in the same way:

\lstset{style=Scala}
\begin{lstlisting}
val combinedFunction = function1 or function2
\end{lstlisting}

\subsection{Consequences of the choice}

The \inlinecode{or} method, in order to be used as an infix operator, has to be defined on the type that represents the first argument, in this case a function. More specifically, all of the function types mentioned in \ref{subsec:functiontypes}. Because Scala doesn't support extension methods, we need to introduce a new type for functions containing this behavior, and an implicit conversion from the normal function type. We will use the same type as the type of a combined function - a \inlinecode{MultiFunctionN} type\footnote{Actually a set of types, one for each $N$, in this thesis only from $0$ to $5$}. The following is required:

\begin{itemize}
	\item \inlinecode{FunctionN} is implicitly convertible into \inlinecode{MultiFunctionN}, creating a default with just one function
	\item \inlinecode{MultiFunctionN} has an operator \inlinecode{or} that will combine it with a different \inlinecode{MultiFunctionN}, creating a new object with concatenation of the functions combined
	\item \inlinecode{MultiFunctionN} will initiate the selection process upon calling \inlinecode{apply()}
\end{itemize}

\subsection{Implementation}

The type \inlinecode{MultiFunctionN}, which will be the main part of the interface for the user, will be just a trait hiding a concrete implementation. The user should never come in contact with the actual implementation, as we do not want him to create instances of it manually. The implementation itself should wrap a list of functions from which to chose, along with some basic configuration, which will be discussed later.

There are two ways for the user how to get a new \inlinecode{MultiFunctionN} instance:

\begin{itemize}
	\item By using the implicit conversion function
	\lstset{style=Scala}
	\begin{lstlisting}
implicit def toMultiFunction1[T1, R](fun: (T1) => R): MultiFunction1[T1, R]
\end{lstlisting}
	\item By calling the \inlinecode{or} method
		\lstset{style=Scala}
	\begin{lstlisting}
def or(fun: (T1) => R): MultiFunction1[T1, R]
	\end{lstlisting}
\end{itemize}

The implicit conversions have to be defined for all the function types separately as publicly accessible methods on an object\footnote{A Scala concept for singleton.}. For this purpose, a special object \inlinecode{Implicits} was introduced - it can be imported into any other Scala source file and the implicit conversions become active in this file (for more details see \ref{sec:implicits}).

The conversion of \inlinecode{FunctionN} to \inlinecode{MultiFunctionN} should always check whether the \inlinecode{FunctionN} instance is not already a \inlinecode{MultiFunctionN} instance as well, and if so, just cast it instead of creating a new wrapper. The same should be done by the \inlinecode{or} function, which can just manually call the conversion on its argument.

Note that declaring the \inlinecode{or} method with \inlinecode{MultiFunctionN} argument directly instead of using the \inlinecode{FunctioN} argument (or its alias) and then manually converting it would cause some issues with implicit \textit{eta-expansion} that will be described later.

%TODO: Def macros?
%TODO: Move to a different section

\section{Usage of the API}

\subsection{Basic use cases}

\subsubsection{Combining two functions}

The most simple and straightforward use-case is to combine two functions previously stored in variables. We use the implicit type conversion and the \inlinecode{or} method.

\lstset{style=Scala}
\begin{lstlisting}
import scalaadaptive.api.Implicits._
val combinedFunc = function1 or function2
\end{lstlisting}

The \inlinecode{function1} and \inlinecode{function2} have to have exactly the same type of \inlinecode{FunctionN}. The \inlinecode{combinedFunc} variable will have a type of \inlinecode{MultiFunctionN}. When exposing the resulting function in a public API, it might be better to enforce the \inlinecode{FunctionN} type for the variable or attribute:

\lstset{style=Scala}
\begin{lstlisting}
val combinedFunc: Function1[Int, Int] = function1 or function2
\end{lstlisting}

This will ensure that the \inlinecode{MultiFunctioN} specific API will remain hidden unless having the \inlinecode{Implicits} explicitly imported again.

\subsubsection{Combining multiple functions}

The \inlinecode{or} calls can be chained and used to combine more than two functions in one expression.

\lstset{style=Scala}
\begin{lstlisting}
import scalaadaptive.api.Implicits._
val combinedFunc = function1 or function2 or function3 or function4
\end{lstlisting}

\subsubsection{Combining function twice}

A combined function can be combined again, no matter whether treated as \inlinecode{FunctionN} or \inlinecode{MultiFunctionN} in the meantime. The resulting combination will be the same as if the combination was done in one expression\footnote{Actually, the \inlinecode{or} call chain is exactly the same case, the \inlinecode{MultiFunctionN} instances are created one by one}.

\lstset{style=Scala}
\begin{lstlisting}
import scalaadaptive.api.Implicits._
val combinedFunc1 = function1 or function2
...
combinedFunct1(...)
...
val combinedFunc2 = combinedFunc1 or function3 or function4
\end{lstlisting}

\subsubsection{Combining lambda expressions}

Just like named function variables, lambda expressions can be combined directly.

\lstset{style=Scala}
\begin{lstlisting}
import scalaadaptive.api.Implicits._
val combinedFunc = { () => obj1.call(...) } or { () => obj2.call(...) }
\end{lstlisting}

\subsubsection{Combining methods}
\label{subsubsec:apimethods}

This is expected to be the most common use-case - we have multiple methods and we want to combine them into a single combined function. As mentioned in \ref{subsec:etaexpansion}, the methods can be easily converted in functions, but unfortunately, in case of the implicit typecast and then a method call, the expansion is not done automatically on the first method. The second method, which is an argument, gets expanded.

\lstset{style=Scala}
\begin{lstlisting}
val combinedFunc = obj.method1 _ or obj.method2
\end{lstlisting}

Note that if the \inlinecode{or} method accepted the \inlinecode{FunctionN} argument and rely on the implicit conversion of the argument as well (just like the call target does), its implicit \textit{eta-expansion} would get blocked and an operator \inlinecode{\_} would be needed as well:

\lstset{style=Scala}
\begin{lstlisting}
val combinedFunc = obj.method1 _ or obj.method2 _
\end{lstlisting}

\subsubsection{Creating a method from combined function}

Even though functions are so common in Scala, there might be situations where we would need to create a method from our combined function. Thanks to the simplified syntax that allows us to define the method body using a one-line expression, quite idiomatic way to create this combined method exists:

\lstset{style=Scala}
\begin{lstlisting}
def combinedMethod(arg: T) = (function1 or function2)(arg)
\end{lstlisting}

The method body consists of creating the combined function object and then immediately applying it. Although this does look elegant, it has a major problem - the \inlinecode{MultiFunctionN} instance is created upon every invocation, which leads to an unnecessary overhead and to loss of all the data locally stored in the instance. In addition, there is no way to access the \inlinecode{MultiFunctionN} internal API (which will be described later).

The preferred, a little less convenient way is to create a private field containing the combined function initialized in constructor and to delegate the method calls to it\footnote{It can be thought of as an analogy to the concept of \textit{property} and its \textit{backing field}}.
 
 \lstset{style=Scala}
 \begin{lstlisting}
 private val combinedInner = function1 or function2
 def combinedMethod(arg: T) = combinedInner(arg)
 \end{lstlisting}
 
 \subsection{Problematic cases}

\subsection{Covariance and contravariance}
%TODO: Object-oriented polymorphism
% http://milessabin.com/blog/2012/04/27/shapeless-polymorphic-function-values-1/

So far, all mentioned usages of the \lstinline|or()| method were limited to functions with the same signatures. Quite common case, however, might be combining multiple functions with slightly different argument and return value types, typically one being a specialized version of the other. For example:

%TODO: replace this example:

The two functions can't be joined using the \lstinline|or()| method, because \lstinline|bubbleSort()| is defined on a more general type than \lstinline|radixSort()|. Let's examine simplified case with more combinations:

\lstset{style=Scala}
\begin{lstlisting}
def fun1(arg: Any): String = ???
def fun2(arg: String): Any = ???
def fun3(arg: String): String = ???

val fun4 = fun3 _ or fun2
val fun5 = fun2 _ or fun3
val fun6 = fun3 _ or fun1
val fun7 = fun1 _ or fun3
\end{lstlisting}

We receive compilation error on lines 5 and 8, in the definition of \lstinline|fun4| and \lstinline|fun7|. Lines 6 and 7 compile correctly. These are the cases where:

\begin{enumerate}
	\item Return type of the function passed in as an argument is a subtype of the return type of the target function
	\item Argument type of the function passed in as an argument is a supertype of the argument type of the target function
\end{enumerate}

The function types (represented as traits) in Scala are defined in the following way:
\lstset{style=Scala}
\begin{lstlisting}
trait Function1[-T1, +R] extends AnyRef
\end{lstlisting}

The type arguments representing the function arguments are defined as contravariant and the type argument representing the return value of the function is defined as covariant. This leads to \lstinline|(String) => String| being a subtype of \lstinline|(String) => Any| and to \lstinline|(Any) => String| being a subtype of \lstinline|(String) => String|. So the \lstinline|or()| method is working flawlessly for the \lstinline|fun5| and \lstinline|fun6|.

Taking into account that \lstinline|or()| is behaving like a commutative infix operator, we would like it to work in the other two cases as well. The two functions combined will always be in a subtype - supertype relation The signature of the function returned has to match the more limiting signature, i.e. the signature,

\begin{lstlisting}
def funA(arg: A): A = ???
def funB(arg: B): B = ???
val funAB: (B with A) => Object = funA _ or funB
\end{lstlisting}

%TODO: Comment case & listing

As we can see, these are the cases where:

\begin{enumerate}
	\item The output type of the function that is passed as an argument is more general (superclass) than the output type of the target function
	\item The argument type of the function that is passed as an argument is more specific (subclass) than the argument type of the target function
\end{enumerate}

This is a case where covariance and contravariance of the type arguments of the functions that our \lstinline|or()| method accepts should be taken into account. Let's consider the following type of the first function:

\lstset{style=Scala}
\begin{lstlisting}
(A) => B
\end{lstlisting}

This function should be combinable using \lstinline|or()| method with any 

\subsection{Generic methods}

%TODO: Solution suggestion - OOP approach, genericity in classes

%TODO: How to solve this issue?

Functions have one major limitation in Scala - they can't have any generic arguments. The signature of a function always has all the argument and return value types specified at compile-time. If we perform the eta-expansion on a generic method, we have to specify the type argument, otherwise, the type arguments will be fixed as Nothing and the function won't be callable:

\lstset{style=Scala}
\begin{lstlisting}
def makeTuple[A, B](a: A, b: B): (A, B) = (a, b)
val fun1 = makeTuple _
// fun1: (Nothing, Nothing) => (Nothing, Nothing)
val fun2 = makeTuple[Int, String] _
// fun2: (Int, String) => (Int, String)
\end{lstlisting}

As the \lstinline|or()| method performs combination of functions into another function, we automatically lose all the generic types involved in the original methods we are expanding and then combining. We can, however, take advantage of the fact that the type arguments being explicitly set in the process of eta-expansion can be generic types of an enclosing structure (generic class or generic method). With this approach, there are two possible patterns of achieving genericity in combined functions:

\begin{enumerate}
	\item Defining a function field inside a generic class
	\lstset{style=Scala}
	\begin{lstlisting}
	def defaultCount[A](list: List[A], item: A) = list.count(_ == item)
	def customCount[A](list: List[A], item: A) = list.filter(_ == item).map((i) => 1).sum
	
	class ListTools[A] {
	val count = defaultCount[A] _ or customCount[A]
	}
	\end{lstlisting}
	\item Defining a generic method by creating the combination and then calling it immediately
	\lstset{style=Scala}
	\begin{lstlisting}
	def count[A](list: List[A], item: A) = (defaultCount _ or customCount)(list, item)
	\end{lstlisting}
\end{enumerate}


Generics solution:
\lstset{style=Scala}
\begin{lstlisting}
def defaultMap[A, B](list: List[A], fun: (A) => B): List[B] = 
list.map(fun)
def iterativeMap[A, B](list: List[A], fun: (A) => B): List[B] =  {
val result = new mutable.MutableList[B]()
for (x <- list) {
result += fun(x)
}
result.toList
}

def map[A, B](list: List[A], fun: (A) => B): List[B] = 
(defaultMap[A, B] _ or iterativeMap[A, B])(list, fun)
\end{lstlisting}

\subsection{Implicit arguments}

Implicit arguments are arguments that will be filled in automatically at invocation by an implicit method with matching signature that is available within the scope. This can be used for different reasons, but the most common is a combination with a type argument that has to have a conversion of some kind. In the Scala terminology, the type has to be \textit{viewable} as some other type. There used to be a specialized syntax called \textit{View bounds} in earlier versions of Scala to support this usage, but it has been deprecated.

%TODO: http://docs.scala-lang.org/tutorials/tour/implicit-parameters.html

\lstset{style=Scala}
\begin{lstlisting}
def bubbleSort[A <% Ordered[A]](list: List[A]): List[A] = ???
def bubbleSort[A](list: List[A])(implicit ord: A => Ordered[A]): List[A] = ???
\end{lstlisting}

The most common usage of implicit arguments is simulating \textit{type classes} from other functional languages like Haskell. We create a generic trait with required methods (representing the type class and its functions) and whenever we want a new type to be member of the type class, we create implementation of the trait and an implicit method that provides the implementation. From now on, the newly added member can be used in any method requiring the implicit conversion just by importing our conversion function into the scope where the method is called.

%TODO: Example of custom "type class" or member?

As with a lot of other features, implicit arguments are supported only by methods, not by functions. Therefore, all of them have to be resolved and fixed when performing eta-expansion, along with all the type arguments. If we set the type arguments to a concrete type, we can provide the implementation in the same way as at the time of invocation, without any problem:

\lstset{style=Scala}
\begin{lstlisting}
def radixSort(list: List[Int]): List[Int] = ???
def bubbleSort[A <% Ordered[A]](list: List[A]): List[A] = ???

val sort = radixSort _ or bubbleSort[Int]
\end{lstlisting}

%TODO: Reference
There is, however, one more option mentioned in [REFERENCE] - the type argument can be set to a type argument of an enclosing scope, making the implicit argument generic again. In this case, the scope in which the type argument is declared has to provide the implicit function implementation. As a result, the implicit argument has to be repeated in the method or class constructor signature.

\lstset{style=Scala}
\begin{lstlisting}
def implicitFun1[A](list: List[A])(implicit ord: A => Ordered[A]): List[A] = ???
def implicitFun2[A](list: List[A])(implicit ord: A => Ordered[A]): List[A] = ???

// Following line won't compile:
// def implicitFun[A](list: List[A]): List[A] = (implicitFun1[A] _ or implicitFun2[A])(list)
def implicitFun[A](list: List[A])(implicit ord: A => Ordered[A]): List[A] = (implicitFun1[A] _ or implicitFun2[A])(list)
\end{lstlisting}

\lstset{style=Scala}
\begin{lstlisting}
def bubbleSort[A](list: List[A])(implicit ord: A => Ordered[A]): List[A] = ???
\end{lstlisting}

\lstset{style=Scala}
\begin{lstlisting}
def implicitFun1[A <% Ordered[A]](list: List[A]): List[A] = ???
def implicitFun2[A <% Ordered[A]](list: List[A]): List[A] = ???

def fun = implicitFun1 _ or implicitFun2
\end{lstlisting}

Interesting thing is that the parser included in the IntelliJ IDEA IDE\footnote{Integrated Development Environment.} Scala plugin that performs background code inspection and immediately highlights compile-time errors doesn't recognize this problem. It was tested in version 2016.3.4 with Scala plugin version 2016.3.8.

%TODO: IntelliJ parser has no problems, compilation shows error

\lstset{style=Scala}
\begin{lstlisting}
def fun: (List[A]) => List[String] = implicitFun1 _ or implicitFun2
\end{lstlisting}

%TODO: Automatically generated type annotation is WRONG!!!

\subsection{Overloading}
Very similar issue is encountered when it comes to overloading - only methods can be overloaded.

%TODO: implementing traits using combined methods
\subsection{Implementing Traits}
Traits in the role of interfaces represent key element of object-oriented programming approach. Providing custom implementations of traits is essential and using adapted functions in this role would be very useful. The key problem is the separation of functions and methods in Scala mentioned in [REF].
%TODO: ADD REFERENCE HERE

The methods defined in traits can be implemented or overridden only by a different method, which will be invoked using virtual method calls. The function defined in the trait using a val keyword is basically a getter which returns the function value, invokable by itself. In this case, the getter has to be overridden, either by a custom getter, or by a field with automatically generated getter. An adapted function generated using the \lstinline|or()| method can be assigned to such a field and thus implementing the trait function getter. An example follows:

\lstset{style=Scala}
\begin{lstlisting}
trait TestTrait {
def testMethod(arg: List[Int]): List[String]
val testFunction: (List[Int]) => List[String]
}

class TestImpl extends TestTrait {
import functionadaptors.Implicits._

def impl1(arg: List[Int]): List[String] = 
arg.map("Num: " + _.toString)
def impl2(arg: List[Int]): List[String] = 
arg.map(i => s"Num: $i")

override val testFunction: (List[Int]) => List[String] = 
impl1 _ or impl2

// Can't implement testMethod using the result of or()
override def testMethod(arg: List[Int]): List[String] = ???
}
\end{lstlisting}

Unfortunately, a lot of the traits we need to provide implementations for are already existing and can use the method format. Manual workaround to implement the method is quite straightforward, but again, it generates unnecessary calls and duplicities in our code:

\lstset{style=Scala}
\begin{lstlisting}
private val adaptedFunction = impl1 _ or impl2
override def testMethod(arg: List[Int]): List[String] = 
adaptedFunction(arg)
\end{lstlisting}

%TODO: Add reference
Or, using the solution that was previously mentioned in [PREVIOUS SECTION], we can even omit the private field declaration and use an expression syntax:

\lstset{style=Scala}
\begin{lstlisting}
override def testMethod(arg: List[Int]): List[String] = 
(impl1 _ or impl2)(arg)
\end{lstlisting}


%TODO: summary of the API approach, definition of key terms and points in adaptive lifecycle - method definition, function / closure creation (eta expansion), function combination, 

%TODO: Thread safety

%TODO: Evaluation, advantages, disadvantages, generation

\section{Additional API features}

\subsection{Combined function configuration}

\subsection{Analytics and control access}

\subsection{Delayed measuring}
\label{subsec:delayed_measuring}

In some specific cases it might be useful to delay the measurement, or, in general, to measure invocation of a different function than the one that has multiple implementation. The implementations can affect something else than their own runtime. Some example use cases might be:

\begin{itemize}
	\item Configuration, or generation of configuration
	\item Expression tree building
	\item Query building
	\item Method chain building
\end{itemize}

It is obvious that our API, which was designed to remain as simple as possible, doesn't support this case. We need to slightly extend it.

\subsubsection{Decision context}

Supposing we already have a mechanism to mark the actual function to measure, we encounter another problem. Making a decision when executing the function with multiple implementation automatically generates a context of the decision - all measured function invocations that were affected by the decision. When measuring the invocation, the library has to know to which context it belongs in order to be able to assign the measured data to the run history of the corresponding function.

The contexts can interleave and we can't match the decision with the invocation by time or location. It is impossible to decide to which decision which invocation belongs automatically - we need support from the library user. The user will have to explicitly state the context whenever invoking the measured function. By doing this, he will pinpoint the moment of decision that affected the invocation.

Practically, we need to introduce a special object - the \textbf{measurement token} - which will represent the context. The \inlinecode{MultiFunction} instances will have a special, modified version of the apply method, which will not trigger the measure of the selected function, but will generate a measurement token, that will be used to measure future function runs.

\lstset{style=Scala}
\begin{lstlisting}
val getConfig = getFastConfig _ or getSlowConfig
val (config, measure) = getConfig^()
...
measure(() => run(config))
\end{lstlisting}

This approach has one main disadvantage compared to the rest of the API - it isn't transparent. The user has to know that he is working with the \inlinecode{MultiFunction}, not just normal function. His assistance is, however, required by the nature of the problem.

%TODO: Use cases - configuration generation, expression tree building, query building...

%TODO: Problems - matching decision with measurement